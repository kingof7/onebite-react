// 1. 원시타입 : 메모리 값 수정 X
// 힙 || 스택
let p1 = 1
// p1   1
p1 = 2
//      2 --> 2는 새로운 메모리 공간에 할당됨
let p2 = 3
// p2    3

// 2. 객체타입 : 메모리 값 수정 O
// 힙   ||  스택
let o1 = {name: "이종화"};
// o1     참조값(주소) 0x0000C     
//        {name: "이종화"}
//        0x0000C 가 {name: "이종화"}을 가리킼
let o2 = o1; // 얕은 복사, 참조값만 o2에 복사, 즉 o1과 o2가 같은 참조값을 가리킴
// o2는    0x0000C 가리킴
o2.name = "홍길동"
// o2는 그대로 0x0000C를 가리키고, 같은 메모리 공간에 {name: "홍길동"}로 값이 수정됨 
// 즉 o1의 값도 수정되게 된다. 왜? 같은 0x0000C 를 가리키니까~
// 즉, 객체를 복사할때는 그냥 대입하면 안됨
// -> 스프레드 문법을 이용해서 새로운 참조값의 새로운 객체를 생성해야함.
// -> 이게 바로 깊은복사임

// 깊은 복사
let o3 = { ...o2 };

// 힙   ||   스택
// o3      새로운 참조값(주소) 0x0010D
//         {name: "이종화"}



// 얕은 비교 : o1 === o3
console.log(o1 === o3); // -> false, 참조값을 비교하므로

// 깊은 비교 : JSON.stringify : 객체를 문자열로 변환한다.
console.log(JSON.stringify(o1) === JSON.stringify(o3)); // true

// 객체타입
// 원시타입 : Number, String, Boolean, Null, Undefined
// 객체타입 : Object -> Array, Function, RegexExp
// Array와 Function은 객체였고, 추가적인 함수 호출, 선언, 순차 저장, 순회가 가능

